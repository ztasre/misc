"""
Project Euler Problem 61
========================

Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers
are all figurate (polygonal) numbers and are generated by the following
formulae:

Triangle     P[3,n]=n(n+1)/2    1, 3, 6, 10, 15, ...
Square       P[4,n]=n^2         1, 4, 9, 16, 25, ...
Pentagonal   P[5,n]=n(3n-1)/2   1, 5, 12, 22, 35, ...
Hexagonal    P[6,n]=n(2n-1)     1, 6, 15, 28, 45, ...
Heptagonal   P[7,n]=n(5n-3)/2   1, 7, 18, 34, 55, ...
Octagonal    P[8,n]=n(3n-2)     1, 8, 21, 40, 65, ...

The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three
interesting properties.

 1. The set is cyclic, in that the last two digits of each number is the
    first two digits of the next number (including the last number with
    the first).
 2. Each polygonal type: triangle (P[3,127]=8128), square (P[4,91]=8281),
    and pentagonal (P[5,44]=2882), is represented by a different number in
    the set.
 3. This is the only set of 4-digit numbers with this property.

Find the sum of the only ordered set of six cyclic 4-digit numbers for
which each polygonal type: triangle, square, pentagonal, hexagonal,
heptagonal, and octagonal, is represented by a different number in the
set.
"""

from functools import reduce
from itertools import permutations

def lastTofirst(n):
    return str(n)[-2:]

def mkcache(n, f):
    """ Generates a cache of numbers up to n using function f """
    return map(f, range(1, n+1))

def polygonal(x):
    """ Generates polygonal functions. """
    def f(n):
        if x % 2 == 0:
            return n*((1 + ((x-4) // 2))*n - ((x-4) // 2))
        else:
            return n*((x-2)*n + (1 - (x-3))) // 2
    return f

cache = {i: set(filter(lambda x: len(str(x)) == 4, filter(lambda x: x < 10000,
    mkcache(10000, polygonal(i))))) for i in range(3, 9)}

def mkdict(polyclass):
    """
    Extracts the first two digits of every element in the class, converts it
    to a string and uses it as a key, the values are lists of numbers that
    have the first two digits as the key.
    """
    temp = dict()
    for elem in polyclass:
        temp.setdefault(str(elem)[0:2], []).append(elem)
    return temp

chaincache = [[mkdict(cache[i]), cache[i]] for i in cache]

"""
    Search over a tree
        * The tree has a depth of 6
            * Each layer in the tree has 

"""

def cyclic_chain():
    # correct idea, but needs to be run across 120 different permutations of
    # how classes can be arranged

    def recur(t, l):
        if len(t) == 6 and str(t[-1])[-2:] == str(t[0])[0:2]:
            # base case
            return t
        elif len(t) == 6:
            # other base case, hits here
            return t[:-1] 
        elif len(t) == 0:
            # initialize, hits here
            for elem in chaincache[0][1]:
                temp = recur(t + (elem,), l)
                if len(temp) == 6:
                    # if you find one with len 6 break out
                    return temp
        else:
            index = len(t)
            last2 = lastTofirst(t[-1])
            try:
                elems = l[index - 1][0][last2]
                temp = t
                for elem in elems:
                    temp = recur(t + (elem,), l)
                    if len(temp) == 6:
                        return temp
            except KeyError:
                # can't chain, break back up
                return t[:-1]
            return t[:-1]

    return list(filter(lambda x: x != None
        , map(lambda x: recur(tuple(), x), permutations(chaincache[1:]))))[0]

# fugly solution, not proud of it
print(sum(cyclic_chain()))
