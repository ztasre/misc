"""
Project Euler Problem 61
========================

Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers
are all figurate (polygonal) numbers and are generated by the following
formulae:

Triangle     P[3,n]=n(n+1)/2    1, 3, 6, 10, 15, ...
Square       P[4,n]=n^2         1, 4, 9, 16, 25, ...
Pentagonal   P[5,n]=n(3n-1)/2   1, 5, 12, 22, 35, ...
Hexagonal    P[6,n]=n(2n-1)     1, 6, 15, 28, 45, ...
Heptagonal   P[7,n]=n(5n-3)/2   1, 7, 18, 34, 55, ...
Octagonal    P[8,n]=n(3n-2)     1, 8, 21, 40, 65, ...

The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three
interesting properties.

 1. The set is cyclic, in that the last two digits of each number is the
    first two digits of the next number (including the last number with
    the first).
 2. Each polygonal type: triangle (P[3,127]=8128), square (P[4,91]=8281),
    and pentagonal (P[5,44]=2882), is represented by a different number in
    the set.
 3. This is the only set of 4-digit numbers with this property.

Find the sum of the only ordered set of six cyclic 4-digit numbers for
which each polygonal type: triangle, square, pentagonal, hexagonal,
heptagonal, and octagonal, is represented by a different number in the
set.
"""

"""
    * 6 cyclic 4-digit numbers. Where each polygonal type is represented by
    a DIFFERENT number in the set.
        * Generate a cache for all classes of polygonal numbers, where the
        cache goes up to 10k.
    * Generate all 6 cycle chains
    * Make boolean function that checks for the property of having every
    element in the 6-cycle represent a different class (covering all 6 classes)
    * Find the smallest cache out of my 6 classes. Generate all cyclic chains
    for every element in that class. Pipe all results into our verification
    function, wait for it to converge.
"""

from functools import reduce
from itertools import permutations

def lastTofirst(n):
    return str(n)[-2:]

def mkcache(n, f):
    """ Generates a cache of numbers up to n using function f """
    return map(f, range(1, n+1))

def polygonal(x):
    """ Generates polygonal functions. """
    def f(n):
        if x % 2 == 0:
            return n*((1 + ((x-4) // 2))*n - ((x-4) // 2))
        else:
            return n*((x-2)*n + (1 - (x-3))) // 2

    return f

cache = {i: set(filter(lambda x: len(str(x)) == 4, filter(lambda x: x < 10000,
    mkcache(10000, polygonal(i))))) for i in range(3, 9)}

"""
    * From every class in the cache generate a dict where the first two digits
    of each number map to a set of numbers that have these two digits.
    * Make a function s.t
        * function takes a number from the class of octagonal numbers below 10k
        * function also tak
        
"""

orderings = set(permutations((3,4,5,6,7)))

def cyclicChain(n):
    solutions = []
    def recur(n, order, sol):
        if len(order) == 0:
            solution.append(sol)
        pass
    map(lambda x: recur(n, x, tuple()), orderings)

    return solutions

    

